import logging
import os
import uuid
import datetime
import tempfile
from dotenv import load_dotenv
from fastapi import FastAPI, BackgroundTasks, HTTPException, Body
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
from typing import Optional

# Load environment variables from .env file
load_dotenv()

# Import our custom modules
import config_generator
import dodger
import youtube_uploader

# Setup Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("app")

app = FastAPI()

def validate_environment():
    """Validates that required environment variables are set."""
    required_vars = []
    optional_vars = {
        "YOUTUBE_PRIVACY_STATUS": "public",
        "PORT": "10000"
    }
    
    # Check YouTube vars only if upload functionality is needed
    # (Not required for /generate_video endpoint)
    youtube_vars = ["YT_REFRESH_TOKEN", "YT_CLIENT_ID", "YT_CLIENT_SECRET"]
    
    missing = []
    for var in required_vars:
        if not os.environ.get(var):
            missing.append(var)
    
    if missing:
        logger.warning(f"Missing optional environment variables: {missing}")
    
    # Log configuration
    logger.info("Environment validation complete")
    logger.info(f"YouTube privacy status: {os.environ.get('YOUTUBE_PRIVACY_STATUS', 'public')}")
    
    return True

# Validate environment on startup
validate_environment()

def cleanup_file(path: str):
    """Deletes the temporary file after use."""
    try:
        if os.path.exists(path):
            os.remove(path)
            logger.info(f"Deleted temp file: {path}")
    except Exception as e:
        logger.error(f"Error deleting file {path}: {e}")

def generate_video_file(save_to_disk: bool = True) -> tuple[str, dict]:
    """
    Helper function to generate a video file.
    
    Args:
        save_to_disk: If True, saves to temp directory. If False, just returns config.
    
    Returns:
        tuple: (output_path, config_dict) if save_to_disk, else (None, config_dict)
    """
    config = config_generator.generate_config()
    
    if not save_to_disk:
        return None, config
    
    filename = f"video_{uuid.uuid4()}.mp4"
    temp_dir = tempfile.gettempdir()
    output_path = os.path.join(temp_dir, filename)
    
    # Ensure temp directory exists
    os.makedirs(temp_dir, exist_ok=True)
    
    try:
        logger.info(f"Generating video: {output_path}")
        dodger.run_game(config, output_path)
        logger.info(f"Video generated successfully: {output_path}")
        return output_path, config
    except Exception as e:
        logger.error(f"Generation failed: {e}", exc_info=True)
        cleanup_file(output_path)
        raise Exception(f"Video generation failed: {str(e)}")

def upload_video_file(
    video_path: str,
    title: str = None,
    description: str = None,
    privacy_status: str = None
) -> dict:
    """
    Helper function to upload a video file to YouTube.
    
    Args:
        video_path: Path to the video file
        title: Video title (optional)
        description: Video description (optional)
        privacy_status: Privacy status (optional)
    
    Returns:
        dict: Contains video_id and url
    """
    # Check if file exists
    if not os.path.exists(video_path):
        raise FileNotFoundError(f"Video file not found: {video_path}")
    
    # Generate default title if not provided
    if not title:
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        title = f"Insane Dodger Gameplay {today} #Shorts"
    
    # Generate default description if not provided
    if not description:
        description = (
            "Can the AI survive this level? ðŸ˜±\n\n"
            "Generated by Python Code.\n"
            "#gaming #coding #python #pygame #shorts"
        )
    
    # Get privacy status
    if not privacy_status:
        privacy_status = os.environ.get("YOUTUBE_PRIVACY_STATUS", "private")
    
    logger.info(f"Uploading video: {video_path}")
    video_id = youtube_uploader.upload_video(
        file_path=video_path,
        title=title,
        description=description,
        privacy_status=privacy_status
    )
    video_url = f"https://youtu.be/{video_id}"
    logger.info(f"Upload successful! URL: {video_url}")
    
    return {
        "video_id": video_id,
        "url": video_url
    }

@app.get("/health")
def health():
    return {"status": "ok", "service": "DodgerGen"}

@app.post("/generate_video")
async def generate_video(background_tasks: BackgroundTasks):
    """
    Route 1: Generate Video
    Generates a new Dodger gameplay video and returns it for download.
    The video is automatically cleaned up after download.
    """
    try:
        output_path, config = generate_video_file(save_to_disk=True)
        filename = os.path.basename(output_path)
        
        # Schedule cleanup after download
        background_tasks.add_task(cleanup_file, output_path)
        
        return FileResponse(
            output_path,
            media_type="video/mp4",
            filename=filename
        )
    except Exception as e:
        logger.error(f"Generation endpoint failed: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": "Game generation failed", "details": str(e)}
        )

class UploadVideoRequest(BaseModel):
    video_path: str
    title: Optional[str] = None
    description: Optional[str] = None
    privacy_status: Optional[str] = None

@app.post("/upload_video")
async def upload_video_endpoint(request: UploadVideoRequest):
    """
    Route 2: Upload Video
    Uploads an existing video file to YouTube.
    
    Request body:
    - video_path: Path to the video file to upload (required)
    - title: Video title (optional, auto-generated if not provided)
    - description: Video description (optional, auto-generated if not provided)
    - privacy_status: "public", "unlisted", or "private" (optional, uses env var or defaults to "private")
    """
    try:
        result = upload_video_file(
            video_path=request.video_path,
            title=request.title,
            description=request.description,
            privacy_status=request.privacy_status
        )
        
        return {
            "status": "success",
            "action": "uploaded",
            "video_id": result["video_id"],
            "url": result["url"],
            "file": request.video_path
        }
        
    except FileNotFoundError as e:
        logger.error(f"Upload failed - file not found: {e}")
        return JSONResponse(
            status_code=404,
            content={"error": "Video file not found", "details": str(e)}
        )
    except ValueError as e:
        logger.error(f"Upload failed - missing credentials: {e}")
        return JSONResponse(
            status_code=400,
            content={"error": "YouTube credentials not configured", "details": str(e)}
        )
    except Exception as e:
        logger.error(f"Upload failed: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": "YouTube upload failed", "details": str(e)}
        )

class GenerateAndUploadRequest(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    privacy_status: Optional[str] = None

@app.post("/generate_and_upload")
async def generate_and_upload(
    background_tasks: BackgroundTasks,
    request: Optional[GenerateAndUploadRequest] = Body(None)
):
    """
    Route 3: Generate and Upload
    Combines Route 1 and Route 2:
    1. Generates a new Dodger gameplay video
    2. Uploads it directly to YouTube
    3. Cleans up the temporary file
    
    This endpoint reuses the logic from /generate_video and /upload_video.
    
    Optional request body:
    - title: Video title (optional, auto-generated if not provided)
    - description: Video description (optional, auto-generated if not provided)
    - privacy_status: "public", "unlisted", or "private" (optional, uses env var or defaults to "private")
    """
    logger.info("Starting automated workflow: Generate â†’ Upload")
    
    output_path = None
    
    try:
        # Step 1: Generate video (reusing Route 1 logic)
        logger.info("Step 1: Generating video...")
        output_path, config = generate_video_file(save_to_disk=True)
        logger.info(f"Video generated: {output_path}")
        
        # Step 2: Upload video (reusing Route 2 logic)
        logger.info("Step 2: Uploading to YouTube...")
        upload_result = upload_video_file(
            video_path=output_path,
            title=request.title if request else None,
            description=request.description if request else None,
            privacy_status=request.privacy_status if request else None
        )
        
        # Step 3: Schedule cleanup
        background_tasks.add_task(cleanup_file, output_path)
        
        return {
            "status": "success",
            "action": "generated_and_uploaded",
            "video_id": upload_result["video_id"],
            "url": upload_result["url"],
            "message": "Video generated and uploaded successfully!"
        }
        
    except Exception as e:
        logger.error(f"Generate and upload failed: {e}")
        # Clean up on any error
        if output_path:
            cleanup_file(output_path)
        
        error_msg = str(e)
        if "generation" in error_msg.lower():
            return JSONResponse(
                status_code=500,
                content={"error": "Game generation failed", "details": error_msg}
            )
        elif "credentials" in error_msg.lower() or "YouTube" in error_msg:
            return JSONResponse(
                status_code=400,
                content={"error": "YouTube upload failed", "details": error_msg}
            )
        else:
            return JSONResponse(
                status_code=500,
                content={"error": "Generate and upload failed", "details": error_msg}
            )

if __name__ == "__main__":
    import uvicorn
    port = int(os.environ.get("PORT", 10000))
    uvicorn.run(app, host="0.0.0.0", port=port)